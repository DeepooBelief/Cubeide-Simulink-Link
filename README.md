# CubeIDE 与 Simulink 集成工作流脚本

## 概述 / Overview

这个 Python 脚本目前只能应用与 STM32F4 系列芯片设计，旨在将 Simulink 生成的 STM32 代码与 CubeIDE 的 C++ 功能及调试等功能结合起来。它的目标是简化 Simulink 与 CubeIDE 之间的工作流，使得开发者能更轻松地将 Simulink 模型与 STM32 硬件进行协作。

This Python script is currently designed for STM32F4 series chips, aiming to integrate Simulink-generated STM32 code with CubeIDE's C++ features and debugging capabilities. Its goal is to simplify the workflow between Simulink and CubeIDE, enabling developers to easily collaborate between Simulink models and STM32 hardware.

## 工作流程 / Workflow

1. **CubeIDE 创建 C++ 项目 / CubeIDE Create C++ Project**  
   在 CubeIDE 中创建一个 C++ 项目，并配置 `.ioc` 文件中的外设（如定时器、GPIO、通信接口等）。

   Create a C++ project in CubeIDE and configure peripherals in the `.ioc` file (e.g., timers, GPIO, communication interfaces).

2. **配置 Simulink / Configure Simulink**  
   运行 Python 脚本。脚本会自动执行以下操作：
   - 创建一个配置好的空的 Simulink 模型文件，供 Simulink 使用的 `.ioc` 文件。
   - 修改 CubeIDE 项目的头文件路径、源文件路径，以及其他相关宏定义。

   Run the Python script. The script will automatically:
   - Create a configured, empty Simulink model file and a `.ioc` file for Simulink.
   - Modify CubeIDE project's header file paths, source file paths, and other related macro definitions.

3. **在 MATLAB 中绘制模型 / Draw Model in MATLAB**  
   经过以上步骤后，开发者就可以在 MATLAB 中使用 Simulink 绘制并模拟模型，并且与 CubeIDE 配合进行调试。

   After completing the steps above, developers can use Simulink in MATLAB to draw and simulate models, and debug with CubeIDE.

## 背景 / Background

Simulink 本身就可以生成 STM32 的代码，并能够直接编译它。详细信息请参考 [MathWorks 官方文档](https://ww2.mathworks.cn/hardware-support/stm32.html)。Simulink 的优势在于过图形化建模和自动代码生成，简化了开发过程，提升了效率，并支持实时仿真、调试和硬件接口。然而，Simulink 生成的 CubeIDE 项目使用 C 语言，且无法直接编译。此时需要配置一些宏定义、引入额外路径才能正常使用，且若希望使用 C++ 库，还需要额外的配置和修改。

Simulink can generate STM32 code and compile it directly. For more details, refer to the [MathWorks official documentation](https://ww2.mathworks.cn/hardware-support/stm32.html). The advantage of Simulink lies in graphical modeling and automatic code generation, which simplifies the development process, improves efficiency, and supports real-time simulation, debugging, and hardware interfacing. However, the CubeIDE project generated by Simulink uses C language, which cannot be compiled directly. It requires configuration of macros and additional paths for proper usage, and additional configuration is needed if C++ libraries are to be used.

这时，Python 脚本的作用就显现出来了，它能够帮助用户在 Simulink 与 CubeIDE 之间建立更高效的连接。

At this point, the Python script comes into play, helping users establish a more efficient connection between Simulink and CubeIDE.

## 仍然需要改进的地方 / Areas for Improvement

目前，如果要使用实时数据显示功能，Simulink 模型就不能包含硬件配置相关的 C 代码（比如使用 SPI 通信的芯片初始化代码）。简而言之，现有的工作流只支持从 `Simulink -> CubeIDE` 的单向流程，但无法直接支持 `硬件函数 -> Simulink -> CubeIDE` 的双向流动。

Currently, if real-time data display functionality is to be used, Simulink models cannot contain C code related to hardware configuration (e.g., chip initialization code for SPI communication). In short, the current workflow only supports the unidirectional flow from `Simulink -> CubeIDE`, but does not directly support bidirectional flow from `hardware functions -> Simulink -> CubeIDE`.

为了解决这个问题，未来可以考虑以下改进：
- 将所有源文件直接配置到 Simulink 模型中，避免手动修改。
- 修改 Makefile，以便支持双向的数据和代码流动。

To address this issue, future improvements may include:
- Directly configuring all source files in the Simulink model to avoid manual modifications.
- Modifying the Makefile to support bidirectional data and code flow.
